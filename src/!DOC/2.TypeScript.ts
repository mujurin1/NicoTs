export let TypeScriptの説明: null;

// =======================================================
// TypeScript の説明 (JavaScript の説明でもあります)
// =======================================================

{
  "TypeScript 型";
  // 


  // TypeScript では「型」を使用してその値の種類を表すことが出来ます


  // 例えば「文字列」や「数値」などの型があります
  // 変数名の右に「:」をつけて型を指定します
  const stringType = "もじ";            // 文字列  string
  const numberType = 1000;              // 数値    number
  const booleanType = true;             // 真偽値  boolean
  const nullType = null;                // null    null
  const undefinedType = undefined;      // undefined  undefined

  // let 変数名: 型;  という形式です

  // この例であげた５つの型は特に「プリミティブ型」と呼ばれるものです
  // プリミティブは「原始的/根源的なもの」という意味です
  // これから色々な型が出てきますが、それらは全てプリミティブ型が集まってできたものです

  // ※この他にも「symbol」や「bigint」などがありますが、
  //    ニコ生ゲームでは不要な知識なので省略します


  "変数";
  //       ↓ number なのでこれは数値型の変数になります
  let num: number;

  // 変数なのでどんどん値を変更することが出来ます
  num = 10; num = 0x10; num = -1;
  // 現在の num は何でしょうか？
  // console.log(num);

  // 変数は「値を入れる箱」と考えるのが JavaScript にはピッタリです
  // そしてその箱にどんな値を入れるかを決定するのが TypeScript の「型」です

  // 型が決まっていると、間違った値を入れることが出来なくなります
  // num = "文字列！";  // ← コメントアウトするとエラーになります
  //                          赤い波線の出ている単語にカーソルを合わせてエラーを読んでみてください


  "定数";
  // 変数は「値が変わる」ことができるので「変数」と呼ばれます
  // 一方で「値が変わらない」ものは「定数」と呼ばれます
  const constString: string = "文字列";

  // 定数は一度中身が決まると変更することが出来ません
  // constString = "コメントアウトするとエラーになります";


  "ブロック";
  // この例でも囲われている「{}」はブロックと呼び、１つのまとまりを表します
  // 基本的にこの例のように何も無い場所でブロックを作る事はありませんが、
  // 関数や if 文、for 文などで使います
  if (true) {
    // ブロックごとにインデントを１つ右に移動することで、コードの可読性を上げます
    // ブロック内で変数を宣言すると、その変数はブロック内でのみ有効です
    let blockNum = 1;
    {
      // 外側のブロックで定義されているブロックは、内側のブロックでも使えます
      let blockNum2 = blockNum;
    }
    // console.log(blockNum2);  // ← エラーになります
    //                                これは blockNum2 が定義されたブロックの外側にいるためです
  }


  "変数の理解度チェック";
  // 変数・定数はプログラミングの基本で大事な物なので、理解度を確認します

  let value1 = 10;
  let value2 = value1;
  // この時点では value1 と value2 はどちらも 10 です

  value1 = -1;
  // value1 に -1 を代入したのでこれは -1 と出力されます
  // console.log(value1);

  // しかし value2 は 10 と出力されます
  // console.log(value2);

  // これは変数を箱として考えると分かりやすいです
  // 最初に value1 という箱を作りました
  // 次に value2 という箱を作り、その中に「value1 の中身をコピー」しました
  // value2 の中に value1 があるわけではなく、value1 の中身が value2 にコピーされたのです

  // プリミティブ型の場合は「値そのもの」がコピーされます
  // これから説明する「配列」「オブジェクト」はプリミティブ型ではないので、コピーの仕方が異なります
  // とりあえず「変数の中身がプリミティブ型の場合は中身をコピーする」と覚えてください

  // コピーなので元の値が無くなったり、変わったりはしません


  "関数の型";
  // 関数にも               ↓引数や            ↓戻り値に型を書けます
  function connectString(a: string, b: string): string {
    return a + b;  // ← これは２つの文字列を繋げた新しい文字を生成し、それを返します
  }
  // 戻り値が「void」の関数は何も返しません
  function reutrnNothing(): void { }
  // 戻り値が「void」の場合は「void型の値を返す」という意味ではなく「何も返さない」という考えてください


  // 関数を使うと特に型の恩恵が得られます
  // 次の空行に「connectString」関数を書いてみてください

  // 引数は string なので文字列を「"」で囲って書きます
  //                             「"」は「SHIFT 2」キーで入力できます


  "型の推論";
  // 型は省略して書くことも出来ます
  // 型を省略出来るのは、その変数の型が予測出来る場合のみです
  // この型の予測を「型推論」と呼びます
  let str1 = "文字列";
  //  ↑ カーソルを合わせると型が表示されます
  //   ↓ 関数の戻り値からも推論されます
  const str2 = connectString(str1, "？");

  // 最初は何がどう推論されるのか分からないと思いますが、省略出来る箇所は省略して楽しましょう


  // これらの型システムが TypeScript の特徴です
  // JavaScript に比べて次の利点があります
  // ・ コードを書いている途中でエラーが分かる (パソコンが勝手に調べて教えてくれる)
  // ・ ドキュメントを読まなくても関数の使い方が分かる

  // プログラムを書いていくと、その値が何のデータを持っているのか分からなくなるときがあります
  // 実際のプログラミングでは自分では書いていないコードもたくさん使います
  // その時にドキュメントを読んだり、コードを読んだり、動作確認しなくても
  // カーソルを合わせるだけで中身が分かる「型」システムはプログラミングをとても簡単なものにします


  "配列";
  // 配列は値が連なったものです
  // 変数を箱に例えると、配列は箱が並んだものです

  // 配列型は「[]」と書きますが普通は「その配列の持つ値」も同時に書きます
  // 「配列の持つ値の型[]」という書き方をします

  //                    ↓ 配列型を表す「[]」
  const numArray: number[] = [1, 2, 3];
  //              ↑ 配列の持つ要素の型を表す「number」

  // この配列は要素に number しか持つことが出来ません
  // そして配列の持っている値は number であることが決まっています
  const numArrayValue = numArray[0];
  //    ↑ number と推論されます

  // 配列はそれがひとつの「配列型」ですが
  // その要素も型の決まった値です


  // 配列の宣言でも型推論が効きます
  const numberArray = [1, 2, 3];
  //    ↑ number[] です


  // そして注意すべき事があります
  // 先ほど定数「const」は「値が変わらない」と説明しました
  // この値とはあくまでも「その箱に入っているもの」のことです

  // numberArray = [7, 8, 9];   // これはエラーになりますが‥
  numberArray[0] = -1;          // これは問題ありません

  // 定数の場合箱の中身は変えられませんが、
  // その箱の中に値の持つ要素は変えることが出来ます

  //                 ↓ この [] で囲われた全体が「stringArray に入っている値」です
  const stringArray = [
    // これらが stringArray の要素です
    "あいうえお",   // ← １つめ (0番目) の要素
    "かきくけこ",   // ← ２つめ (1番目) の要素
    "さしすせそ",   // ← ３つめ (2番目) の要素
  ];

  //         ↓ ０番目の要素を指定
  stringArray[0] = "なにぬねの";  // これは問題ありません
  // stringArray の「０番目の値」を「なにぬねの」に変更。OK!

  // stringArray = ["ABCDE", "FGHIJ", "KLMNO"];  // これはエラーになります
  // stringArray そのものを変更。ダメ！

  // 定数の値の要素の変更については次のオブジェクトで更に詳しく説明します
  // 今はそういうものなんだと知っておいてください


  "オブジェクト";
  // オブジェクトは「値の集合」です
  // 配列は値が並んでいるので
  const arrayType = [1, 2, 3];          // 配列は Array型 です
  //    ↑ カーソルを合わせると「number[]」と表示されます
  //       これは「number型の配列」を表しています
  const objectType = { key: "value" };  // オブジェクトは Object型 です
  //    ↑ カーソルを合わせると「{ key: string }」と表示されます
  //       オブジェクトとは「値の集合」です
  const objectType2 = { num: 10, str: "文字列", bool: false };
  //       このようにオブジェクトは複数の値を持つことが出来ます
  //       これは、


  "リテラル型 ユニオン型 (ちょっと難しい)";
  // ０または１のような「特定の値に特化した型」を指定することが出来ます
  // これは「リテラル型」と呼びます
  let zeroOrOne: 0 | 1;
  zeroOrOne = 0;
  // zeroOrOne = num; // number型 は０と１以外の可能性があるためエラーになります


  // また文字列または数値のような「複数の型」を指定する事もできます
  // これは「ユニオン型」と呼びます
  let boolOrNum: boolean | number;
  boolOrNum = true;
  // strOrNum = "string型 は boolean | number に含まれていないのでエラーになります";

  // リテラル型とユニオン型を組み合わせることもできます
  let boolOrTwo: boolean | 2 = 2;
  let zeroOrAorBorBoolean: 0 | "A" | "B" | boolean = "A";
  // zeroOrAorBorBoolean = 1;   // もちろん１は含まれないのでエラーになります


  // TypeScript の説明はこのくらいにしておきます
  // 詳しくは https://typescriptbook.jp/reference に書いていますが
  // あまりニコ生ゲームでは使わない知識もあるので気が向いたら読んでみてください
}


import { createFont } from "../utils";

/**
 * プレイヤー間での操作の共有
 */
export function MULTI_global_event() {
  const scene = new g.Scene({ game: g.game });
  g.game.pushScene(scene);
  scene.onLoad.add(loaded);

  function loaded(scene: g.Scene) {
    /* ==========【マルチプレイゲームとランキングゲームの違い】==========
     * ランキングゲームは１つのゲームを１人で遊びます
     * このゲームはプレイヤーごとに独立しています
     * 他のプレイヤーの操作が影響しない完全なソロプレイゲームです
     * 
     * ※プレイヤー間で相互に影響するゲームはランキングゲームでは作れません
     * 
     * 
     * しかしマルチプレイゲームは１つのゲームを複数人で遊びます
     * ただ１つのゲームを複数のプレイヤーで同時に操作します
     * 
     * あるプレイヤーの操作でゲームの状態が変化すると、
     * その影響は全てのプレイヤーに反映します
     * 
     * 例としてクリックしたプレイヤーのIDを表示するラベルを作ります
     */

    // ★クリック可能なラベルを作成
    const showClickerLabel = new g.Label({
      scene, parent: scene,
      font: createFont({ size: 40 }),
      text: "まだクリックされていません",
      touchable: true,
    });
    // ★ラベルをクリックしたプレイヤー名を表示
    showClickerLabel.onPointDown.add(e => {
      showClickerLabel.text = `クリックしたプレイヤー: ${e.player?.id}`;
      showClickerLabel.invalidate();
    });


    /* ==========【グローバルイベント】==========
     * この例では誰かがクリックすると全てのプレイヤーの画面でテキストが変わりました
     * 
     * これは、画面をクリックした時のイベント
     * つまり「PointDown イベント」が全てのプレイヤーに共有されたためです
     * 
     * このようにプレイヤー同士で共有されるイベントを「グローバルイベント」と呼びます
     * 
     * 今回の例では「PointDown イベント」ですが、具体的な種類/内容に関わらず
     * 「プレイヤー同士で共有されるイベント」を「グローバルイベント」と呼びます
     * 
     * 
     * 【Akashic Engine の仕組み】
     * Akashic Engine ではグローバルイベントは全てのプレイヤーに同じ内容で共有されます
     * 特定のプレイヤーのみ受け取るグローバルイベントが 多い/少ない/違う ということはあり得ません
     * 
     * ニコ生ゲームでは途中参加やタイムシフトの視聴時にも全く同じプレイ画面が再生されます
     * これは全てのプレイヤーが同じグローバルイベントを同じように処理するためです
     * 
     * (デフォルトでは) プレイヤーの操作イベントは全てグローバルイベントになっています
     * あらゆるプレイヤーの操作はグローバルイベントとして他のプレイヤーに共有されます
     */


    /* ==========【他のプレイヤーと共有したくないイベント】==========
     * グローバルイベントは全てのプレイヤーに共有されます
     * これはゲームを作る上で不都合な場合があります
     * 
     * 例えば次のシナリオを考えてみます
     * 1. プレイヤーはそれぞれ初期値１を持っています
     * 2. ボタンをクリックするとこの値が１増えます
     *    この時増えるのはそれをクリックしたプレイヤーの値のみです
     * 3. 各プレイヤーは自分の値を他のプレイヤーと共有します
     * 
     * ※グローバルイベントのみでもこれを作ることは出来ますが、
     *   今回は 3 の時点で共有したい。選択中の値を共有したくないものとします
     * 
     * プレイヤーは画面をクリックすることで自分の値を変更しますが、
     * グローバルイベントでは全てのプレイヤーの値が変化していまいます
     * 
     * これをどう実現するかについて、
     * まずは 1、2 を実装した次の例を見てください
     */

    let count = 1;
    // ★クリック可能なラベルを作成
    const incrementLabel = new g.Label({
      scene, parent: scene,
      font: createFont({ size: 40 }),
      text: `あなたの値: ${count}`,
      y: 200,
      touchable: true,
      // ★この local:true が大事です
      local: true,
    });
    // ★ラベルをクリックしたらカウントを増やす
    incrementLabel.onPointDown.add(e => {
      count += 1;
      incrementLabel.text = `あなたの値: ${count}`;
      incrementLabel.invalidate();
    });


    /* ==========【ローカルイベント】==========
     * この例ではクリックしたプレイヤーの画面のみテキストが変わりました
     * 
     * これは、画面をクリックした時のイベント
     * つまり「PointDown イベント」が共有されなかったためです
     * 
     * このように共有されない、
     * そのプレイヤーのみで処理されるイベントを「ローカルイベント」と呼びます
     * 
     * 前のグローバルイベントの例との違いは local:true です
     * 
     * クリック操作イベントがグローバルイベントになるかは、
     * エンティティの生成時の local で決定します
     * 
     * これを指定されていない。もしくは local:false の場合は「グローバルイベント」
     * local:true を指定した場合は「ローカルイベント」になります
     * 
     * また、この共有されるイベントと同様にそれぞれのエンティティを
     * 「グローバルエンティティ」「ローカルエンティティ」と呼びます
     * 
     * 
     * ※local 未指定時は「グローバルエンティティ」になります
     *   グローバルエンティティのクリック操作イベントは「グローバルイベント」です
     */


    /* ==========【任意のイベント】==========
     * 他のプレイヤーに共有しないイベントについては十分ですが、
     * これだけではまだゲームを作れません
     * 
     * 今回の例に出したシナリオの３つ目
     * 「自分の値を他のプレイヤーと共有する」
     * を作ることができません
     * 
     * クリック操作イベントは
     * 「グローバルイベント」と「ローカルイベント」
     * のどちらかであるとを説明しました
     * 
     * この２つのイベントにはそれぞれどんなものがあるのか、
     * 特に、他のプレイヤーと共有する「グローバルイベント」は重要です
     * 
     * まずは一番興味のあるであろう「任意のイベント」をグローバルイベントとして共有する方法です
     * 
     * 実際に 3 を実装した次の例を見てください
     * ※コード例の後に日本語で解説があります
     */

    // ★クリック可能なラベルを作成
    const shareCountLabel = new g.Label({
      scene, parent: scene,
      font: createFont({ size: 40 }),
      text: "まだ共有されていません",
      y: 300,
      touchable: true,
      // ★今回のボタンも local:true です
      local: true,
    });
    // ★ラベルをクリックしたら自分の値を共有する
    shareCountLabel.onPointDown.add(e => {
      // ★共有したい任意のイベントを作成します
      const customEvent = new g.MessageEvent({ count });
      // ★イベントを実際に共有します
      g.game.raiseEvent(customEvent);
    });

    // ★「任意のイベント」が共有された時に実行する関数を登録
    scene.onMessage.add(e => {
      // ★イベントを共有したプレイヤー
      const sharePlayer = e.player;
      if (sharePlayer == null) return;
      // ★共有したプレイヤーの値
      const shareCount = e.data.count;
      if (shareCount == null) return;

      shareCountLabel.text = `共有したプレイヤー: ${sharePlayer.id}  値:${shareCount}`;
      shareCountLabel.invalidate();
    });


    /* ==========【任意のイベントの扱い方】==========
     * 少し長いコードなので日本語で説明します
     * 
     * 1. 自分の値を共有するためのラベルを作成
     *       shareCountLabel = new g.Label(...)
     * 
     * 2. 任意のイベントを共有する関数を作成・登録
     *       shareCountLabel.onPointDown.add(...)
     * 
     *     任意のイベントを作成      new g.MessageEvent({ count })
     *     作成したイベントを共有    g.game.raiseEvent(customEvent)
     * 
     * 3. 任意のイベントを受け取った時の関数を作成・登録
     *       scene.onMessage.add(...)
     * 
     * 
     * 【2 任意のイベントを共有する】
     * クリック操作イベントでは、その処理が発生した時にそのイベントは自動で共有されました
     * しかし、任意のイベントではそのイベントを作成・共有を自力で行う必要があります
     * 
     * 任意のイベントは「MessageEvent」として扱われます
     * このイベントは好きな値を持つことができます
     * 
     * そして任意のイベントを共有するには g.game.raiseEvent を使用します
     * 
     * ※「好きな値」には実際は制限がありますが、コラムで説明します
     * 
     * 
     * 【3 任意のイベントを受け取った時】
     * クリック操作イベントなどの他のイベントと同様に、
     * イベントが発生した際の関数を登録する必要があります
     * 
     * 任意のイベントの場合は、そのイベントを受け取った時に発生します
     * イベントの登録には scene.onMessage を使用します
     * 
     * 引数では player にそれを共有したプレイヤーの情報
     *          data   に共有したときの内容が入っています
     * 
     * 
     * onMessage が呼び出されるにはそのシーンが現在のシーンである必要があります
     * 現在のシーンの onMessage で登録されている全ての関数が実行されます
     */


    /* ==========【コラム】==========
     * 
     * 
     * 
     * 
     * 
     * 
     */
  }
}
